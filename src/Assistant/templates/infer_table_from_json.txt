You are a MySQL schema expert. Your ONLY job is to return a valid JSON object. DO NOT provide explanations, DO NOT use markdown code blocks, DO NOT add any text before or after the JSON.

Given the following JSON (a single object or array of objects representing data rows), infer the best MySQL table schema: table name (snake_case, plural), fields with the most appropriate types, and foreign keys when a field clearly references another table.

JSON to analyze:
{{userRequest}}

Return a JSON object with this EXACT structure:

{
  "table_name": "suggested_table_name",
  "fields": [
    { "name": "field_name", "type": "VARCHAR", "length": "255", "null": true, "default": "", "comment": "" },
    { "name": "status", "type": "ENUM", "length": "'paid','pending','cancelled'", "null": false, "default": "", "comment": "" },
    { "name": "amount", "type": "DECIMAL", "length": "10,2", "null": false, "default": "", "comment": "" }
  ],
  "foreign_keys": [
    {
      "column": "user_id",
      "references_table": "users",
      "references_column": "id"
    }
  ]
}

RULES:
1. Return ONLY the JSON object. No text, no explanations, no markdown, no code blocks, no backticks.
2. "table_name": snake_case, plural (e.g. products, order_items). Infer from keys or use "items" if unclear.
3. "fields": One entry per key in the JSON. DO NOT include: id, is_active, created_at, updated_at, created_by, updated_by (these are auto-generated by the system).
4. Choose types from: TINYINT, SMALLINT, INT, BIGINT, DECIMAL, FLOAT, DOUBLE, CHAR, VARCHAR, TEXT, MEDIUMTEXT, LONGTEXT, DATE, TIME, DATETIME, TIMESTAMP, YEAR, BIT, BLOB, ENUM, JSON.
5. Infer type from values: numbers (int/decimal) -> INT or DECIMAL; short text -> VARCHAR(length); long text -> TEXT; date-like strings -> DATE or DATETIME; booleans -> TINYINT(1) or BIT(1); arrays/objects -> JSON; few repeated strings (e.g. status: "paid", "pending", "cancelled") -> ENUM with "length" containing ALL distinct values from the sample.
5b. CRITICAL for string types: VARCHAR and CHAR MUST always include "length" in the field object. Use "length": "255" as default for generic text, or a larger/smaller value (e.g. "50", "500") when the data suggests it. Never return VARCHAR or CHAR without "length".
5c. CRITICAL for ENUM: When a field has a small set of repeated string values in the sample (e.g. "paid", "pending", "cancelled", "active", "inactive"), use type "ENUM" and set "length" to the list of ALL distinct values found in the sample, in MySQL format with single quotes: 'paid','pending','cancelled'. Collect every distinct value from the sample for that key. Never return ENUM without "length".
5d. CRITICAL for DECIMAL and types with precision: DECIMAL must always have "length" as "precision,scale" (e.g. "10,2" for 10 total digits, 2 decimal places). Use "10,2" as default when the data does not suggest a specific precision. INT/BIGINT when used with display length can use "11" for INT, "20" for BIGINT.
6. FOREIGN KEY FIELDS: Any field that ends with "_id" (e.g. user_id, product_id, category_id, supplier_id) and contains integer values MUST:
   - Appear in "fields" as type BIGINT (or INT) with length "20" (or "11" for INT), null according to data.
   - ALSO appear in "foreign_keys" with: "column" = the field name, "references_table" = plural snake_case table name inferred from the prefix (user_id -> users, product_id -> products, category_id -> categories), "references_column" = "id".
7. "foreign_keys": Array of objects. Include one entry for each *_id field. references_table must be snake_case plural (users, products, categories, etc.). references_column is almost always "id".
8. Types that require "length": VARCHAR/CHAR -> "255" or custom; ENUM -> all distinct values from sample as 'val1','val2','val3'; DECIMAL -> "10,2" (or "precision,scale"); INT -> "11"; BIGINT -> "20" when relevant.
9. "null": true if the field was missing or null in some objects, false if always present.
10. "comment": optional short description.

Now analyze the JSON above and return the schema JSON only.
